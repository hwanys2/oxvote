{% extends 'voting/base.html' %}

{% block title %}투표 결과 - {{ question.text|truncatechars:30 }}{% endblock %}

{% block content %}
<div class="card">
    <div class="card-body p-5">
        <div class="text-center mb-4">
            <h2 class="question-text">{{ question.text }}</h2>
            <div class="alert alert-success">
                <i class="fas fa-check-circle me-2"></i>
                투표가 완료되었습니다!
            </div>
        </div>
        
        <div id="resultsContainer">
            {% if question.show_results %}
                <div class="mb-4">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span class="fw-bold text-success">
                            <i class="fas fa-circle text-success me-1"></i>
                            O (찬성)
                        </span>
                        <span id="oCount" class="badge bg-success">{{ question.o_votes }}표</span>
                    </div>
                    <div class="progress progress-custom mb-2">
                        <div id="oProgress" class="progress-bar progress-bar-o" role="progressbar" style="width: {{ question.o_percentage }}%"></div>
                    </div>
                    <div class="text-center">
                        <span id="oPercentage" class="fw-bold text-success">{{ question.o_percentage }}%</span>
                    </div>
                </div>
                
                <div class="mb-4">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span class="fw-bold text-danger">
                            <i class="fas fa-times text-danger me-1"></i>
                            X (반대)
                        </span>
                        <span id="xCount" class="badge bg-danger">{{ question.x_votes }}표</span>
                    </div>
                    <div class="progress progress-custom mb-2">
                        <div id="xProgress" class="progress-bar progress-bar-x" role="progressbar" style="width: {{ question.x_percentage }}%"></div>
                    </div>
                    <div class="text-center">
                        <span id="xPercentage" class="fw-bold text-danger">{{ question.x_percentage }}%</span>
                    </div>
                </div>
                
                <div class="text-center">
                    <h5>총 투표수: <span id="totalVotes" class="text-primary">{{ question.total_votes }}</span>표</h5>
                </div>
            {% else %}
                <div class="text-center text-muted">
                    <i class="fas fa-eye-slash fa-3x mb-3"></i>
                    <h4>결과가 아직 공개되지 않았습니다</h4>
                    <p>선생님이 결과를 공개할 때까지 기다려주세요.</p>
                </div>
            {% endif %}
        </div>
        
        <div class="text-center mt-4">
            <button id="refreshBtn" class="btn btn-outline-primary btn-custom me-2">
                <i class="fas fa-sync-alt me-2"></i>
                새로고침
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
const questionId = '{{ question.id }}';
let socket = null;
let reconnectInterval = null;
let isConnecting = false;
let fallbackInterval = null;
let websocketFailed = false;

function updateStats(data) {
    const resultsContainer = document.getElementById('resultsContainer');
    
    if (data.show_results) {
        resultsContainer.innerHTML = `
            <div class="mb-4">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="fw-bold text-success">
                        <i class="fas fa-circle text-success me-1"></i>
                        O (찬성)
                    </span>
                    <span class="badge bg-success">${data.o_votes}표</span>
                </div>
                <div class="progress progress-custom mb-2">
                    <div class="progress-bar progress-bar-o" role="progressbar" style="width: ${data.o_percentage}%"></div>
                </div>
                <div class="text-center">
                    <span class="fw-bold text-success">${data.o_percentage}%</span>
                </div>
            </div>
            
            <div class="mb-4">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="fw-bold text-danger">
                        <i class="fas fa-times text-danger me-1"></i>
                        X (반대)
                    </span>
                    <span class="badge bg-danger">${data.x_votes}표</span>
                </div>
                <div class="progress progress-custom mb-2">
                    <div class="progress-bar progress-bar-x" role="progressbar" style="width: ${data.x_percentage}%"></div>
                </div>
                <div class="text-center">
                    <span class="fw-bold text-danger">${data.x_percentage}%</span>
                </div>
            </div>
            
            <div class="text-center">
                <h5>총 투표수: <span class="text-primary">${data.total_votes}</span>표</h5>
            </div>
        `;
    } else {
        resultsContainer.innerHTML = `
            <div class="text-center text-muted">
                <i class="fas fa-eye-slash fa-3x mb-3"></i>
                <h4>결과가 아직 공개되지 않았습니다</h4>
                <p>선생님이 결과를 공개할 때까지 기다려주세요.</p>
            </div>
        `;
    }
}

function connectWebSocket() {
    if (isConnecting || (socket && socket.readyState === WebSocket.CONNECTING)) {
        return;
    }
    
    isConnecting = true;
    
    // WebSocket URL 구성 (HTTPS인 경우 wss, HTTP인 경우 ws)
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/vote/${questionId}/`;
    
    console.log('Connecting to WebSocket:', wsUrl);
    
    socket = new WebSocket(wsUrl);
    
    socket.onopen = function(e) {
        console.log('WebSocket connection opened');
        isConnecting = false;
        
        // 연결 재시도 인터벌 정리
        if (reconnectInterval) {
            clearInterval(reconnectInterval);
            reconnectInterval = null;
        }
        
        // 초기 통계 요청
        socket.send(JSON.stringify({
            'type': 'get_stats'
        }));
    };
    
    socket.onmessage = function(e) {
        try {
            const data = JSON.parse(e.data);
            console.log('WebSocket message received:', data);
            
            if (data.type === 'vote_stats') {
                updateStats(data.data);
            } else if (data.type === 'error') {
                console.error('WebSocket error:', data.message);
            }
        } catch (error) {
            console.error('Error parsing WebSocket message:', error);
        }
    };
    
    socket.onclose = function(e) {
        console.log('WebSocket connection closed:', e.code, e.reason);
        isConnecting = false;
        socket = null;
        
        // 연결 실패가 지속되면 fallback 사용
        if (e.code === 1006 || e.code === 1011) {
            websocketFailed = true;
            console.log('WebSocket repeatedly failed, switching to fallback polling');
            startFallbackPolling();
            return;
        }
        
        // 자동 재연결 (3초 후)
        if (!reconnectInterval && !websocketFailed) {
            reconnectInterval = setInterval(() => {
                console.log('Attempting to reconnect...');
                connectWebSocket();
            }, 3000);
        }
    };
    
    socket.onerror = function(e) {
        console.error('WebSocket error:', e);
        isConnecting = false;
        websocketFailed = true;
        console.log('WebSocket error occurred, switching to fallback polling');
        startFallbackPolling();
    };
}

function startFallbackPolling() {
    console.log('Starting fallback polling mechanism for vote results');
    
    // 기존 WebSocket 재연결 시도 중단
    if (reconnectInterval) {
        clearInterval(reconnectInterval);
        reconnectInterval = null;
    }
    
    // 즉시 한 번 실행
    fetchStatsHTTP();
    
    // 2초마다 폴링
    if (!fallbackInterval) {
        fallbackInterval = setInterval(fetchStatsHTTP, 2000);
    }
}

function fetchStatsHTTP() {
    fetch(`/api/stats/${questionId}/`, {
        method: 'GET',
        headers: {
            'Accept': 'application/json',
            'Cache-Control': 'no-cache'
        }
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('Received data via HTTP fallback (vote result):', data);
        updateStats(data);
    })
    .catch(error => {
        console.error('Error fetching stats via HTTP:', error);
    });
}

document.getElementById('refreshBtn').addEventListener('click', function() {
    if (websocketFailed || !socket || socket.readyState !== WebSocket.OPEN) {
        // HTTP fallback 사용
        fetchStatsHTTP();
    } else {
        socket.send(JSON.stringify({
            'type': 'get_stats'
        }));
    }
});

// 페이지 로드 시 초기화
document.addEventListener('DOMContentLoaded', function() {
    console.log('Vote result page loaded, initializing...');
    
    // WebSocket 연결 시도
    connectWebSocket();
    
    // 5초 후 WebSocket이 연결되지 않으면 fallback으로 전환
    setTimeout(() => {
        if (!socket || socket.readyState !== WebSocket.OPEN) {
            console.log('WebSocket connection timeout, switching to fallback');
            websocketFailed = true;
            startFallbackPolling();
        }
    }, 5000);
});

// 페이지 언로드 시 정리
window.addEventListener('beforeunload', function() {
    if (reconnectInterval) {
        clearInterval(reconnectInterval);
    }
    if (fallbackInterval) {
        clearInterval(fallbackInterval);
    }
    if (socket) {
        socket.close();
    }
});
</script>
{% endblock %}
